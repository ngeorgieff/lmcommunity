{
  "id" : 10583903,
  "description" : "",
  "group" : "_WeenigWare",
  "appliesTo" : "AlarmCountByDevice.id && AlarmCountByDevice.key && AlarmCountByDevice.company",
  "technology" : "",
  "tags" : "",
  "checksum" : "263287eeda3c1bfcc1fa63bcbc5406e1",
  "lineageId" : "n6CVnC2fQGWrDYFrls-tbw",
  "name" : "AlarmCountByDevice",
  "displayName" : "Alarm Counts for this Device by LogicModule",
  "version" : 1586961525,
  "auditVersion" : 0,
  "hasMultiInstances" : true,
  "collectInterval" : 60,
  "collectMethod" : "batchscript",
  "collectorAttribute" : {
    "name" : "batchscript",
    "linuxCmdline" : "",
    "linuxScript" : "",
    "groovyScript" : "import javax.crypto.Mac\nimport javax.crypto.spec.SecretKeySpec\nimport org.apache.commons.codec.binary.Hex\nimport groovy.json.JsonSlurper\n\ndef generate_headers(id, key, path) {\n  try {\n    // Create encryption signature for authorization request\n    Long epoch_time = System.currentTimeMillis()  // Get current system time (epoch time)\n    Mac hmac = Mac.getInstance(\"HmacSHA256\")\n    hmac.init(new SecretKeySpec(key.getBytes(), \"HmacSHA256\"))\n    signature = Hex.encodeHexString(hmac.doFinal(\"GET${epoch_time}${path}\".getBytes())).bytes.encodeBase64()\n    // return headers to main function\n    return [\"Authorization\": \"LMv1 $id:$signature:$epoch_time\", \"Content-Type\": \"application/json\"]\n  } catch (Exception err) {\n    // If error occurred, print the error message\n    println(\"ERROR: Unable to establish encryption for $path. Attempting next resource...\\n${err.message}\")\n  }\n}\n\ndef get_response(resource, parameters, account, headers) {\n  try {\n    boolean proceed = true  // Boolean used to determine if additional pagination is required\n    // Map to store query results for each endpoint.  Contains a list to store actual returned values and a boolean to determine if successful\n    Map results = [\"response\": [],\n             \"success\" : true]\n    add_query_parameters(resource, parameters)\n    // Add initial offset and size values to appropriate categories (skips metrics category since it's stagnate)\n    while (proceed) {\n      // Used for paginating through all availabe results.  Grabs 1000 at a time and moves offset if another query is required.\n      Map query = query_resource(account, parameters, headers)\n      // Query each API endpoint for a response (Should receive as Map)\n      // If the response was successful (including status and error messages), proceed to printing results\n      if (query && query?.data && query?.status == 200 && query?.errmsg?.toUpperCase() == \"OK\") {\n        if (resource != \"metrics\") {\n          results.response.addAll(query.data.items)   // Add all the data items found to our results map data list\n          if (query?.data?.items?.size() < parameters.details.size) {\n            // If we received less than 1000 results\n            proceed = false   // There is no need to execute another API query with a shifted offset\n          } else {    // Otherwise\n            parameters.details.offset += parameters.details.size\n            // Shift the offset to start 1000 numbers from current position\n          }\n        } else {\n          results.response = query.data   // Add all the data items found to our results map data list\n          proceed = false   // We've successfully queried all values.  End while loop\n        }\n      } else {\n        // If response was not successful, print eror message for each category that failed and continue to next endpoint\n        // If response error and status can be determined, print them.  Otherwise, use UNKNOWN\n        println(\"ERROR: Failed to query $resource API Endpoint...\\n\" +\n            \"${query?.errmsg?.toUpperCase() ?: 'UNKNOWN'} (STATUS: ${query?.status ?: 'UNKNOWN'})\")\n        results.success = false   // Set success value to false since we failed our API query\n        proceed = false   // End while loop because of failure and proceed to next endpoint\n      }\n    }\n    return results  // Return results to main function\n  } catch (Exception err) {\n    println(\"ERROR: Script failed while attempting to query $resource API endpoint...\\n${err?.message}\")\n  }\n}\n\ndef add_query_parameters(category, parameters) {\n  // Add size and offset field to map (only if collectors or admins category)\n  if (category != \"metrics\") {\n    Map query_details = [\"size\"  : 1000,\n               \"offset\": 0]\n    // If there's already a details key in the details map\n    if (parameters.details) {\n      parameters.details << query_details\n      // Append the query details information to the pre-existing details map\n    } else {  // Otherwise, create a details key and assign it the query details map as a value\n      parameters.put(\"details\", query_details)\n    }\n  }\n}\n\ndef query_resource(account, details, headers) {\n  try {\n    // Configure request url from account, path, and authorization headers\n    String url = \"https://${account}.logicmonitor.com/santaba/rest${details.path}?${pack_parameters(details.details)}\"\n    // Return query response, converted from JSON to usable map\n    return new JsonSlurper().parseText(url.toURL().getText(useCaches: true, allowUserInteraction: false, requestProperties: headers))\n  } catch (Exception err) {\n    // If error occurred, print the error message\n    println(\"ERROR: Unable to query ${details.path} for details.\\n${err.message}\")\n  }\n}\n\ndef pack_parameters(query_details) {\n  // If additional query details are located in map, include them in url string\n  List pairs = []\n  query_details?.each { k, v ->\n    pairs.add(\"${k}=${v}\")\n  }\n  return pairs.join(\"&\")\n}\n\nMap credentials = [\n  \"id\"   : hostProps.get(\"AlarmCountByDevice.id\"),\n  \"key\"  : hostProps.get(\"AlarmCountByDevice.key\"),\n  \"account\": hostProps.get(\"AlarmCountByDevice.company\")\n]\n\ndeviceId = hostProps.get(\"system.deviceid\")\n\nMap resources = [\n  \"devices\": [\"path\": \"/device/devices/${deviceId}/devicedatasources\", \"details\": [\"fields\":\"dataSourceId,dataSourceDisplayName,dataSourceType,instanceNumber\"]],\n  \"alerts\": [\"path\": \"/device/devices/${deviceId}/alerts\", \"details\": [\"fields\": \"severity,resourceTemplateId,resourceTemplateName\"]],\n]\n\nif (credentials.account && credentials.id && credentials.key) {\n  resources.each() { k, v ->\n    Map headers = generate_headers(credentials.id, credentials.key, v.path)\n    if (headers) {\n      Map response = get_response(k, v, credentials.account, headers)\n      if (response?.success) {resources[k][\"data\"] = response.response}\n    }\n  }\n  returnData = [:]\n  resources.devices.data.each { //loop through all devices in the response data (should be only one)\n    if(it.instanceNumber > 0){ //include only logicmodules that have valid instances\n      returnData[it.dataSourceId] = [\"name\":it.dataSourceDisplayName, \"type\":it.dataSourceType, \"alarmCount\":0] //setup a map entry for the device\n    }\n  }\n  resources.alerts.data.each{returnData[it.resourceTemplateId].alarmCount += 1}\n  returnData.each{ k, v ->\n    println(\"${k}.alarmCount: ${v.alarmCount}\")}\n  return 0\n} else {\n  println(\"Device is not configured with the necessary portal credentials to proceed with API queries.\\nPlease ensure that \\\"lmaccount\\\", \\\"lmaccess.id\\\", and \\\"lmaccess.key\\\" are set in the collector properties section!\\nExiting Program...\")\n  return 1\n}",
    "scriptType" : "embed",
    "windowsCmdline" : "",
    "windowsScript" : ""
  },
  "enableAutoDiscovery" : true,
  "autoDiscoveryConfig" : {
    "persistentInstance" : false,
    "disableInstance" : false,
    "deleteInactiveInstance" : false,
    "instanceAutoGroupMethod" : "ilp",
    "instanceAutoGroupMethodParams" : "logicmodule.type",
    "scheduleInterval" : 1440,
    "method" : {
      "name" : "ad_script",
      "type" : "embeded",
      "winScript" : null,
      "winCmdline" : null,
      "linuxCmdline" : null,
      "linuxScript" : null,
      "groovyScript" : "import javax.crypto.Mac\nimport javax.crypto.spec.SecretKeySpec\nimport org.apache.commons.codec.binary.Hex\nimport groovy.json.JsonSlurper\n\ndef generate_headers(id, key, path) {\n  try {\n    // Create encryption signature for authorization request\n    Long epoch_time = System.currentTimeMillis()  // Get current system time (epoch time)\n    Mac hmac = Mac.getInstance(\"HmacSHA256\")\n    hmac.init(new SecretKeySpec(key.getBytes(), \"HmacSHA256\"))\n    signature = Hex.encodeHexString(hmac.doFinal(\"GET${epoch_time}${path}\".getBytes())).bytes.encodeBase64()\n    // return headers to main function\n    return [\"Authorization\": \"LMv1 $id:$signature:$epoch_time\", \"Content-Type\": \"application/json\"]\n  } catch (Exception err) {\n    // If error occurred, print the error message\n    println(\"ERROR: Unable to establish encryption for $path. Attempting next resource...\\n${err.message}\")\n  }\n}\n\ndef get_response(resource, parameters, account, headers) {\n  try {\n    boolean proceed = true  // Boolean used to determine if additional pagination is required\n    // Map to store query results for each endpoint.  Contains a list to store actual returned values and a boolean to determine if successful\n    Map results = [\"response\": [],\n             \"success\" : true]\n    add_query_parameters(resource, parameters)\n    // Add initial offset and size values to appropriate categories (skips metrics category since it's stagnate)\n    while (proceed) {\n      // Used for paginating through all availabe results.  Grabs 1000 at a time and moves offset if another query is required.\n      Map query = query_resource(account, parameters, headers)\n      // Query each API endpoint for a response (Should receive as Map)\n      // If the response was successful (including status and error messages), proceed to printing results\n      if (query && query?.data && query?.status == 200 && query?.errmsg?.toUpperCase() == \"OK\") {\n        if (resource != \"metrics\") {\n          results.response.addAll(query.data.items)   // Add all the data items found to our results map data list\n          if (query?.data?.items?.size() < parameters.details.size) {\n            // If we received less than 1000 results\n            proceed = false   // There is no need to execute another API query with a shifted offset\n          } else {    // Otherwise\n            parameters.details.offset += parameters.details.size\n            // Shift the offset to start 1000 numbers from current position\n          }\n        } else {\n          results.response = query.data   // Add all the data items found to our results map data list\n          proceed = false   // We've successfully queried all values.  End while loop\n        }\n      } else {\n        // If response was not successful, print eror message for each category that failed and continue to next endpoint\n        // If response error and status can be determined, print them.  Otherwise, use UNKNOWN\n        println(\"ERROR: Failed to query $resource API Endpoint...\\n\" +\n            \"${query?.errmsg?.toUpperCase() ?: 'UNKNOWN'} (STATUS: ${query?.status ?: 'UNKNOWN'})\")\n        results.success = false   // Set success value to false since we failed our API query\n        proceed = false   // End while loop because of failure and proceed to next endpoint\n      }\n    }\n    return results  // Return results to main function\n  } catch (Exception err) {\n    println(\"ERROR: Script failed while attempting to query $resource API endpoint...\\n${err?.message}\")\n  }\n}\n\ndef add_query_parameters(category, parameters) {\n  // Add size and offset field to map (only if collectors or admins category)\n  if (category != \"metrics\") {\n    Map query_details = [\"size\"  : 1000,\n               \"offset\": 0]\n    // If there's already a details key in the details map\n    if (parameters.details) {\n      parameters.details << query_details\n      // Append the query details information to the pre-existing details map\n    } else {  // Otherwise, create a details key and assign it the query details map as a value\n      parameters.put(\"details\", query_details)\n    }\n  }\n}\n\ndef query_resource(account, details, headers) {\n  try {\n    // Configure request url from account, path, and authorization headers\n    String url = \"https://${account}.logicmonitor.com/santaba/rest${details.path}?${pack_parameters(details.details)}\"\n    // Return query response, converted from JSON to usable map\n    return new JsonSlurper().parseText(url.toURL().getText(useCaches: true, allowUserInteraction: false, requestProperties: headers))\n  } catch (Exception err) {\n    // If error occurred, print the error message\n    println(\"ERROR: Unable to query ${details.path} for details.\\n${err.message}\")\n  }\n}\n\ndef pack_parameters(query_details) {\n  // If additional query details are located in map, include them in url string\n  List pairs = []\n  query_details?.each { k, v ->\n    pairs.add(\"${k}=${v}\")\n  }\n  return pairs.join(\"&\")\n}\n\nMap credentials = [\n  \"id\"   : hostProps.get(\"AlarmCountByDevice.id\"),\n  \"key\"  : hostProps.get(\"AlarmCountByDevice.key\"),\n  \"account\": hostProps.get(\"AlarmCountByDevice.company\")\n]\n\ndeviceId = hostProps.get(\"system.deviceid\")\n\nMap resources = [\n  \"devices\": [\"path\": \"/device/devices/${deviceId}/devicedatasources\", \"details\": [\"fields\":\"dataSourceId,dataSourceDisplayName,dataSourceType,instanceNumber\"]],\n]\n\nif (credentials.account && credentials.id && credentials.key) {\n  resources.each() { k, v ->\n    Map headers = generate_headers(credentials.id, credentials.key, v.path)\n    if (headers) {\n      Map response = get_response(k, v, credentials.account, headers)\n      if (response?.success) {resources[k][\"data\"] = response.response}\n    }\n  }\n  resources.devices.data.each{\n    if(it.instanceNumber > 0){\n      println(\"${it.dataSourceId}##${it.dataSourceDisplayName}######logicmodule.type=${it.dataSourceType}\")\n    }\n  }\n  return 0\n} else {\n  println(\"Device is not configured with the necessary portal credentials to proceed with API queries.\\nPlease ensure that \\\"lmaccount\\\", \\\"lmaccess.id\\\", and \\\"lmaccess.key\\\" are set in the collector properties section!\\nExiting Program...\")\n  return 1\n}\n"
    },
    "filters" : [ {
      "attribute" : "##WILDALIAS##",
      "operation" : "NotEqual",
      "value" : "Alarm Counts by Device and LogicModule",
      "comment" : ""
    } ]
  },
  "dataPoints" : [ {
    "id" : 15715,
    "dataSourceId" : 10583903,
    "name" : "alarmCount",
    "description" : "",
    "alertTransitionInterval" : 0,
    "alertClearTransitionInterval" : 0,
    "type" : 2,
    "dataType" : 7,
    "maxDigits" : 4,
    "postProcessorMethod" : "namevalue",
    "postProcessorParam" : "##WILDVALUE##.alarmCount",
    "rawDataFieldName" : "output",
    "maxValue" : "",
    "minValue" : "",
    "userParam1" : "",
    "userParam2" : "",
    "userParam3" : "",
    "alertForNoData" : 1,
    "alertExpr" : "",
    "alertExprNote" : "",
    "alertSubject" : "",
    "alertBody" : "",
    "enableAnomalyAlertSuppression" : ""
  }, {
    "id" : 15716,
    "dataSourceId" : 10583903,
    "name" : "ExecutionTime",
    "description" : "The amount of time it takes for the data to be collected.",
    "alertTransitionInterval" : 0,
    "alertClearTransitionInterval" : 0,
    "type" : 2,
    "dataType" : 4,
    "maxDigits" : 4,
    "postProcessorMethod" : "none",
    "postProcessorParam" : "",
    "rawDataFieldName" : "responseTime",
    "maxValue" : "",
    "minValue" : "",
    "userParam1" : "",
    "userParam2" : "",
    "userParam3" : "",
    "alertForNoData" : 1,
    "alertExpr" : "",
    "alertExprNote" : "",
    "alertSubject" : "",
    "alertBody" : "",
    "enableAnomalyAlertSuppression" : ""
  } ],
  "enableEriDiscovery" : false,
  "eriDiscoveryInterval" : -1,
  "eriDiscoveryConfig" : null
}